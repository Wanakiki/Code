## 1037. K 连续位的最小翻转次数

2021-02-18 16:26:08

### 题目

在仅包含 ``0`` 和 ``1`` 的数组 ``A`` 中，一次*``K`` 位翻转</em>包括选择一个长度为 ``K`` 的（连
续）子数组，同时将子数组中的每个 ``0`` 更改为 ``1``，而每个 ``1`` 更改为 ``0``。

返回所需的 ``K`` 位翻转的最小次数，以便数组没有值为 ``0`` 的元素。如果不可能，返回 ``-1``。   

 

**示例 1：**

```
输入：A = [0,1,0], K = 1
输出：2
解释：先翻转 A[0]，然后翻转 A[2]。
```

**示例 2：**

```
输入：A = [1,1,0], K = 2
输出：-1
解释：无论我们怎样翻转大小为 2 的子数组，我们都不能使数组变为 [1,1,1]。
```

**示例 3：**

```
输入：A = [0,0,0,1,0,1,1,0], K = 3
输出：3
解释：
翻转 A[0],A[1],A[2]: A变成 [1,1,1,1,0,1,1,0]
翻转 A[4],A[5],A[6]: A变成 [1,1,1,1,1,0,0,0]
翻转 A[5],A[6],A[7]: A变成 [1,1,1,1,1,1,1,1]
```

 

**提示：**


- ``1 <= A.length <= 30000``
- ``1 <= K <= A.length``



[LeetCode链接](https://leetcode-cn.com/problems/minimum-number-of-k-consecutive-bit-flips/)    

### 思路及代码

考虑从左向右为翻转顺序，左侧已经翻转过的已经满足条件的数据可以不做考虑，因此可以采用贪心做法，判断每个被K覆盖的范围是否需要进行翻转。

但直接模拟这一翻转过程会直接超时，看过题解才知道要用差分数组来解题，使用差分数组来记录翻转的信息，实际上不进行翻转。了解这一点之后，题目比较简单。

```cpp
class Solution {
public:
    int minKBitFlips(vector<int>& A, int K) {
        int res = 0;
        int len = A.size();
        vector<int> diff(len + 1, 0);
        int count = 0;
        for(int i = 0; i < len; i++){
            count += diff[i];
            bool flag = (A[i] + count & 1) == 0;
            // if(i + K > len && flag){
            //     return -1;
            // }
            // if(flag){
            //     diff[i] += 1;
            //     count++;
            //     res += 1;
            //     diff[i + K] -= 1;
            // }
            if(flag){
                if(i + K > len){
                    return -1;
                }
                res++;
                count++;
                diff[i + K]--;
            }
        }
        return res;
    }
};
```