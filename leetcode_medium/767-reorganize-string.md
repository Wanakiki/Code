## 778. 重构字符串

2020-11-30 20:20:07

### 题目

给定一个字符串``S``，检查是否能重新排布其中的字母，使得两相邻的字符不同。

若可行，输出任意可行的结果。若不可行，返回空字符串。

**示例 1:**

```

输入: S = "aab"
输出: "aba"
```

**示例 2:**

```

输入: S = "aaab"
输出: ""
```

**注意:**


- ``S`` 只包含小写字母并且长度在``[1, 500]``区间内。



### 思路及代码

个人感觉这是一个看了之后感觉不难但是无从下手的题目，最后看了官方的题解才做出来。官方题解给了两种解答方式，使用大顶堆和贪心算法，因为我最初的思路和贪心算法比较类似，所以采用了后者。

首先需要知道的是，当某个字幕出现的次数超过字符串长度一半时，无论如何都不能做到相同字母不相邻，可以细分两种情况进行讨论：

假设字符串长度为偶数n，那么索引为奇数的位置和索引为偶数的位置是相同的，容易知道字母能够出现的最大次数为``n/2``，且该字母放在奇偶位置等价。

假设字符串长度为奇数n，那么索引为奇数的位置会比索引为偶数的位置少一个，所以此时字母的最大出现次数为``(n+1)/2``，且最大字母一定要放在偶数位置。

这里比较巧妙的一点是，在整型除法下，不管字符串的长度是奇数还是偶数，``(n+1)/2``的值均能代表字母能够出现的最大次数，可以依次来判断不满足要求的情况。

在上面分析的基础上，我们可以发现偶数位置是比较重要的，对于字符串长度为偶数的情况，奇偶位置等价，对于字符串长度为奇数的情况，由于字符串中可能存在出现次数恰好为``(n+1)/2``的字母，在没有确定该字母是否存在时不能直接把字母放在偶数位置，否则结果必然存在相同字母相邻的情况。

在明白这点之后，便可以用贪心的做法，遍历字符串，统计各个字母出现的次数，排除掉不成立的情况。之后遍历字母，优先考虑奇数位置，在找到出现次数为``(n+1)/2``的字母前把当前遍历到的字母放在奇数位置上，直到达到字符串末尾，过程中如果遇到了出现次数达到最大的字母之后则将其放在偶数位置。如果把所有的奇数位置都放完，剩下的字母应该直接放到偶数位置上，因为此时只有两种情况，待遍历的字母出现次数为``(n+1)/2``或者不存在出现次数为``(n+1)/2``的字母。

上面的过程说起来比较复杂，简单来讲就是先把出现次数没有达到最大的字母放到奇数位置上，放完之后便把整个字符串划分为了一个个的小格子，这个时候再往格子里面放字母一定是不相邻的。这里还有比较关键的一点，在放奇数位置时，如果放到末尾字母还有剩余，此时把字母放到偶数位置，是否会出现相同字母相邻的情况。答案是不会出现，原因也很简单，因为我们是优先放奇数位置的，当技术位置放满之后再放偶数位置，因为该字母的出现次数为``m <= n/2``，在最坏的情况下二者仍然有3的距离，可以自己写简单的例子进行判断，官方题解有比较详细的推导，我个人的看法是可以直接把奇偶位置看成一个位置，最差的情况也只是刚刚布满，不会重复。

```cpp
class Solution {
public:
    string reorganizeString(string S) {
        if(S.size() < 2){
            return S;
        }
        vector<int> count(128, 0);
        int s_max = 0;
        for(auto c : S){
            count[c]++;
            s_max = max(s_max, count[c]);
        }
        
        int len = S.size();
        if(s_max > (len + 1) / 2){
            return "";
        }
        int even_index = 0, odd_index = 1;  // 返回字符串索引
        int half_len = len / 2;
        string res(len, 'a');
        for(int i = 'a'; i <= 'z'; i++){
            while(count[i] && count[i] <= half_len && odd_index < len){
                count[i]--;
                res[odd_index] = i;
                odd_index += 2;
            }
            while(count[i]){
                count[i]--;
                res[even_index] = i;
                even_index += 2;
            }
        }
        return res;
    }
};
```

上面的代码基本上是照着官方的代码打下来的，在while循环处官方代码的判断很精炼。