## 837. 新21点

2020年6月3日

### 题目

爱丽丝参与一个大致基于纸牌游戏 &ldquo;21点&rdquo; 规则的游戏，描述如下：

爱丽丝以 ``0`` 分开始，并在她的得分少于 ``K`` 分时抽取数字。 抽取时，她从 ``[1, W]`` 的范围中随机获得一个整数作为分数进行累计，其中 ``W`` 是整数。 每次抽取都是独立的，其结果具有相同的概率。

当爱丽丝获得不少于 ``K`` 分时，她就停止抽取数字。 爱丽丝的分数不超过 ``N`` 的概率是多少？

**示例****1****：**

```
输入：N = 10, K = 1, W = 10
输出：1.00000
说明：爱丽丝得到一张卡，然后停止。
```

**示例****2****：**

```
输入：N = 6, K = 1, W = 10
输出：0.60000
说明：爱丽丝得到一张卡，然后停止。
在 W = 10 的 6 种可能下，她的得分不超过 N = 6 分。
```

**示例 ****3****：**

```
输入：N = 21, K = 17, W = 10
输出：0.73278
```

**提示：**

- ``0 <= K <= N <= 10000``
- ``1 <= W <= 10000``
- 如果答案与正确答案的误差不超过 ``10^-5``，则该答案将被视为正确答案通过。
- 此问题的判断限制时间已经减少。


### 代码

个人不是很擅长数学题，遇到这个题直接懵掉了，看过[题解](https://leetcode-cn.com/problems/new-21-game/solution/huan-you-bi-zhe-geng-jian-dan-de-ti-jie-ma-tian-ge/)之后发现也没有那么难。核心在概率的递推关系：

$$dp[x] = \frac{1}{W} (dp[x+1] + dp[x+2] + ... +dp[x+w])$$

在了解到上面的递推关系后，另外还需要注意只有当当前分数小于K时才能抽卡，所以大于等于K时的概率可以直接计算出来，其余的项目可以通过递推关系得到。

```cpp
class Solution {
public:
    double new21Game(int N, int K, int W) {
        double res[K + W];
        double cur = 0;

        // 大于等于K
        for(int i = K; i < K + W; i++){
            if(i <= N){
                res[i] = 1;
            }
            else{
                res[i] = 0;
            }
            cur += res[i];
        }

        // 小于K
        for(int i = K - 1; i >= 0; i--){
            res[i] = cur / W;
            cur = cur + res[i] - res[i + W];
        }
        return res[0];
    }
};
```