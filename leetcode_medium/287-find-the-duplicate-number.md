## 287. 寻找重复数

2020年5月26日

### 题目

给定一个包含*n + 1* 个整数的数组 *nums*，其数字都在 1 到*n*之间（包括 1 和*n*），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。

**示例 1:**

```
输入: [1,3,4,2,2]
输出: 2
```

**示例 2:**

```
输入: [3,1,3,4,2]
输出: 3
```

**说明：**


- **不能**更改原数组（假设数组是只读的）。
- 只能使用额外的<em>O</em>(1) 的空间。
- 时间复杂度小于<em>O</em>(<em>n</em><sup>2</sup>) 。
- 数组中只有一个重复的数字，但它可能不止重复出现一次。


### 代码

在题目的复杂度要求下，我没有找到合适的解法，下述解法借鉴自官方题解中的二进制做法，思路基本一致，对实现细节进行了一些改动。

做法的总体思路是统计1~n和nums数组中的元素每个二进制位1的个数，由于nums在最好的情况下，nums数组相当于在1~n的基础上添加了一个重复元素，此时观察每个二进制位的累加和，如果大于1~n中对应的数值，则证明重复元素在该位为1。

在此基础上进一步考虑，当nums数组中元素重复了多次，此时相当于用重复元素对原数组中的数据进行了替换。如果重复元素的值在某个二进制位为1，则替换后会让该位的累加和变大，仍满足初步分析条件。

```cpp
class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        int res = 0;
        int max_bit = 31;
        int cur = 1;

        for(int bit = 0; bit <= max_bit; bit++){
            cur = 1 << bit;
            int sum = 0, real_sum = 0;
            for(int i = 0; i < nums.size(); i++){
                if(i && i & cur){
                    sum ++;
                }
                if(nums[i] & cur){
                    real_sum++;
                }
            }

            if(real_sum > sum){
                res += cur;
            }
        }
        return res;
    }
};
```