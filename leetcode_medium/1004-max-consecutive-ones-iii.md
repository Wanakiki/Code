## 1046. 最大连续1的个数 III

2021-02-19 16:32:03

### 题目

给定一个由若干 ``0`` 和 ``1`` 组成的数组 ``A``，我们最多可以将 ``K`` 个值从 0 变成 1 。

返回仅包含 1 的最长（连续）子数组的长度。

 

**示例 1：**

```
输入：A = [1,1,1,0,0,0,1,1,1,1,0], K = 2
输出：6
解释： 
[1,1,1,0,0,1,1,1,1,1,1]
粗体数字从 0 翻转到 1，最长的子数组长度为 6。
```

**示例 2：**

```
输入：A = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3
输出：10
解释：
[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]
粗体数字从 0 翻转到 1，最长的子数组长度为 10。
```

 

**提示：**


- ``1 <= A.length <= 20000``
- ``0 <= K <= A.length``
- ``A[i]`` 为 ``0`` 或 ``1`` 



[LeetCode链接](https://leetcode-cn.com/problems/max-consecutive-ones-iii/)

### 思路及代码

```cpp
class Solution {
public:
    int longestOnes(vector<int>& A, int K) {
        // 题目要求返回最长的连续数组，可以确定K次变换均参与到该数组当中，换句话说该K次变换是连续的（相邻两个变换之间不存在零）
        // 因此可以统计所有连续K次变换的可能情况 使用双指针

        int count = 0;
        int res = 0;
        int left = 0, right = 0;
        while(right < A.size()){
            if(A[right] == 0){
                count++;
            }

            // 当变换次数超过K时需要更新左侧位置 注意这里一定能找到
            while(count > K){
                if(A[left++] == 0){
                    count--;
                    break;
                }
            }
            right++;
            res = max(res, right - left);   // 更新位置时是左闭右开区间
        }
        return res;
    }
};
```