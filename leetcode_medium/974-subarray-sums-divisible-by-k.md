## 974. 和可被 K 整除的子数组

2020年5月27日

### 题目

给定一个整数数组 ``A``，返回其中元素之和可被 ``K`` 整除的（连续、非空）子数组的数目。

**示例：**

```
输入：A = [4,5,0,-2,-3,1], K = 5
输出：7
解释：
有 7 个子数组满足其元素之和可被 K = 5 整除：
[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]
```

**提示：**


- ``1 <= A.length <= 30000``
- ``-10000 <= A[i] <= 10000``
- ``2 <= K <= 10000``


### 代码

两个数相加后再取模和两个数各自取模再相加的值是相等的，减法同样满足。在此基础上，通过计算数组的前缀和取模后的值并统计每个值出现的次数，便能得到最终的结果。

对数组求前缀和并对K取模，如果取模后的值为0，则代表可被K整除，并且可以减去所有取模后为0的前缀数组，构成新的可被K整除的子数组。

若当前位置求前缀和取模后的值不为零，假设其为x，则同样可以和之前出现的所有取模前缀和为x的前缀构成满足条件的子数组。

如果在过程中出现了负数，考虑对其加K，将结果限制在[0,K)范围内。

```cpp
class Solution {
public:
    int store[10000] = {0};
    int subarraysDivByK(vector<int>& A, int K) {
        int res = 0;
        int cur = 0;
        for(int i = 0; i < A.size(); i++){
            cur = (cur + A[i]) % K;
            // 不关心cur的实际值，只关心求模的值
            if(cur < 0){
                cur += K;
            }
            if(store[cur]){
                res += store[cur];
            }
            store[cur]++;

            // 恰好除尽
            if(cur == 0){
                res ++;
            }
        }
        return res;
    }
};
```