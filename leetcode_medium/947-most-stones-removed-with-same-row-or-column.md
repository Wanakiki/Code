## 984. 移除最多的同行或同列石头

2021-01-15 20:21:21

### 题目

``n`` 块石头放置在二维平面中的一些整数坐标点上。每个坐标点上最多只能有一块石头。

如果一块石头的 **同行或者同列** 上有其他石头存在，那么就可以移除这块石头。      

给你一个长度为 ``n`` 的数组 ``stones`` ，其中 ``stones[i] = [x<sub>i</sub>, y<sub>i</sub>]`` 表示第 ``i`` 块石头的 
位置，返回 **可以移除的石子** 的最大数量。

 

**示例 1：**

```

输入：stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]
输出：5
解释：一种移除 5 块石头的方法如下所示：
1. 移除石头 [2,2] ，因为它和 [2,1] 同行。
2. 移除石头 [2,1] ，因为它和 [0,1] 同列。
3. 移除石头 [1,2] ，因为它和 [1,0] 同行。
4. 移除石头 [1,0] ，因为它和 [0,0] 同列。
5. 移除石头 [0,1] ，因为它和 [0,0] 同行。
石头 [0,0] 不能移除，因为它没有与另一块石头同行/列。
```

**示例 2：**

```

输入：stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]
输出：3
解释：一种移除 3 块石头的方法如下所示：
1. 移除石头 [2,2] ，因为它和 [2,0] 同行。
2. 移除石头 [2,0] ，因为它和 [0,0] 同列。
3. 移除石头 [0,2] ，因为它和 [0,0] 同行。
石头 [0,0] 和 [1,1] 不能移除，因为它们没有与另一块石头同行/列。
```

**示例 3：**

```

输入：stones = [[0,0]]
输出：0
解释：[0,0] 是平面上唯一一块石头，所以不可以移除它。
```

 

**提示：**


- ``1 <= stones.length <= 1000``
- ``0 <= x<sub>i</sub>, y<sub>i</sub> <= 10<sup>4</sup>``
- 不会有两块石头放在同一个坐标点上


### 思路及代码

一个比较巧妙使用并查集的题目，题意稍微有点迷，一开始也没有找到合适的办法，看过题解之后才知道是并查集。

解决问题需要知道一点，对于行坐标或者列坐标有重合的节点，可以看作连通区域，该区域只需要保留一个节点，剩下的节点都能够被去掉。例如：``[[0,1],[0,2],[1,0]]``三个坐标，可以随意去掉两个节点构成最优结果。

想明白这点之后，问题就转化成了求平面上有多少个连通区域，刚好是并查集能够解决的问题。但是实际上应用时却有一些细节需要注意：

一是数据范围：题目数据范围总的来说不算太大，完全可以开辟足够长的数组保存节点信息，按照一般做法来实现并查集。但问题的实际规模取决于总结点数，这里用哈希表来保存数据更加合适。

二是节点联通规则的确定：怎样判断两个节点是否属于连通区域？该点的横坐标或者纵坐标有一项与区域重合，在不断扩大区域的同时，区域的横纵坐标跨度也是在不断增加的。为此，并查集要能够同时包括横纵两个坐标，关于如何存储这种关系我没有想到合适的办法，但官方题解给到了一个很巧妙的做法。

首先把横纵坐标区分开来，对纵坐标累加常数a，避免二者出现重合，之后每个节点本身横纵坐标便是并查集需要合并的两个点。这样，对于新增节点，不论是横纵那个坐标与当前区域存在交集，都能反映到最顶端的节点索引处，满足并查集的原理。方法看起来比较难以理解，但是实现之后会发现非常巧妙。

```cpp
class UnionSet {
public:
    unordered_map<int, int> hash;


    // 基于哈希表的查找
    int findx(int x){
        if(hash.find(x) != hash.end()){
            while(hash[x] != x){
                hash[x] = hash[hash[x]];
                x = hash[x];
            }
        }
        else{
            hash[x] = x;
        }
        return hash[x];
    }

    void unionNode(int x, int y){
        int a = findx(x);
        int b = findx(y);
        if(a != b){
            hash[b] = a;
        }
    }

    int Count(){
        int res = 0;
        for(auto i = hash.begin(); i != hash.end(); i++){
            if(i->first == i->second){
                res++;
            }
        }
        return res;
    }
};

class Solution {
public:
    int removeStones(vector<vector<int>>& stones) {
        int n = stones.size();
        UnionSet us;
        for(int i = 0; i < n; i++){
            us.unionNode(stones[i][0], stones[i][1] + 10001);
        }
        return n - us.Count();
    }
};
```

